# Public API Design for WASM Exports

**Project**: Quantum Crypto Audit Library
**Target**: JavaScript/TypeScript consumption
**Design Philosophy**: Simple, predictable, type-safe

---

## 1. API Design Principles

### 1.1 Core Principles

1. **Simplicity First**: 5 core functions cover 95% of use cases
2. **Async-Ready**: All functions return Promises for WASM compatibility
3. **Type-Safe**: Full TypeScript definitions generated by wasm-bindgen
4. **Error Explicit**: Result types, never throw uncaught exceptions
5. **Zero-Config Default**: Sensible defaults, optional configuration

### 1.2 Target Audience

- **Security Engineers**: Auditing production codebases
- **DevOps Teams**: CI/CD pipeline integration
- **Developers**: Local pre-commit checks
- **Compliance Teams**: Regular security assessments

---

## 2. Core API Functions

### 2.1 `audit_file()` - Single File Audit

**Purpose**: Audit a single file for quantum-vulnerable cryptography

```rust
#[wasm_bindgen]
pub fn audit_file(
    content: &str,
    file_path: &str,
    config_json: &str
) -> Result<JsValue, JsValue>
```

**TypeScript Signature**:
```typescript
function audit_file(
  content: string,
  file_path: string,
  config_json: string
): Promise<AuditReport>
```

**Parameters**:

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `content` | `string` | Yes | File content as UTF-8 string |
| `file_path` | `string` | Yes | File path (for language detection and reporting) |
| `config_json` | `string` | Yes | Configuration as JSON string (use `"{}"` for defaults) |

**Returns**: `Promise<AuditReport>` - Audit results with findings and risk score

**Errors**:
- `ParseError`: Invalid file content or unsupported language
- `ConfigError`: Invalid configuration JSON
- `InvalidInput`: File too large or path contains invalid characters

**Example**:
```typescript
import init, { audit_file } from './pkg/quantum_crypto_audit.js';

await init();

const pythonCode = `
from cryptography.hazmat.primitives.asymmetric import rsa
private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048
)
`;

const config = JSON.stringify({
  severity_threshold: "Medium",
  strip_comments: true
});

try {
  const report = await audit_file(pythonCode, "crypto.py", config);
  console.log(`Found ${report.findings.length} issues`);
  console.log(`Risk level: ${report.risk_score.risk_level}`);
} catch (error) {
  console.error("Audit failed:", error);
}
```

---

### 2.2 `audit_directory()` - Multi-File Audit

**Purpose**: Audit multiple files in a single pass with aggregated results

```rust
#[wasm_bindgen]
pub fn audit_directory(
    files_json: &str,
    config_json: &str
) -> Result<JsValue, JsValue>
```

**TypeScript Signature**:
```typescript
function audit_directory(
  files_json: string,
  config_json: string
): Promise<AuditReport>
```

**Parameters**:

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `files_json` | `string` | Yes | JSON array of `{path, content}` objects |
| `config_json` | `string` | Yes | Configuration as JSON string |

**Input Format**:
```typescript
const files = [
  {
    path: "src/crypto.py",
    content: "import rsa\n..."
  },
  {
    path: "src/auth.js",
    content: "const crypto = require('crypto')\n..."
  }
];

const filesJson = JSON.stringify(files);
```

**Returns**: `Promise<AuditReport>` - Combined report for all files

**Example**:
```typescript
const files = [
  { path: "backend/crypto.py", content: pythonCode },
  { path: "frontend/auth.ts", content: typescriptCode },
  { path: "shared/utils.go", content: goCode }
];

const report = await audit_directory(
  JSON.stringify(files),
  JSON.stringify({ severity_threshold: "High" })
);

// Report contains findings from all files
report.findings.forEach(finding => {
  console.log(`${finding.location.file}:${finding.location.line}`);
  console.log(`  ${finding.description}`);
});
```

---

### 2.3 `get_supported_patterns()` - Pattern Discovery

**Purpose**: List all supported cryptographic patterns and their metadata

```rust
#[wasm_bindgen]
pub fn get_supported_patterns() -> JsValue
```

**TypeScript Signature**:
```typescript
function get_supported_patterns(): PatternInfo[]
```

**Returns**: Array of pattern metadata objects

**Return Type**:
```typescript
interface PatternInfo {
  id: string;              // "RSA-001"
  name: string;            // "RSA Key Generation"
  pattern_type: string;    // "RSA"
  severity: Severity;      // "Critical"
  quantum_vulnerable: boolean;
  description: string;
  recommendation: string;
  regex_preview: string;   // For documentation
}
```

**Example**:
```typescript
const patterns = get_supported_patterns();

// Filter to quantum-vulnerable patterns only
const quantumVulnerable = patterns.filter(p => p.quantum_vulnerable);

console.log("Quantum-vulnerable patterns detected:");
quantumVulnerable.forEach(p => {
  console.log(`  ${p.id}: ${p.name} (${p.severity})`);
});

// Output:
// RSA-001: RSA Key Generation (Critical)
// ECC-001: Elliptic Curve Cryptography (Critical)
// DH-001: Diffie-Hellman Key Exchange (High)
```

**Use Cases**:
- Documentation generation
- Pattern selection in UI
- Custom filtering logic
- Educational tools

---

### 2.4 `validate_config()` - Configuration Validation

**Purpose**: Validate configuration before running audit (fail fast)

```rust
#[wasm_bindgen]
pub fn validate_config(config_json: &str) -> Result<JsValue, JsValue>
```

**TypeScript Signature**:
```typescript
function validate_config(config_json: string): Promise<ConfigValidation>
```

**Returns**: Validation result with errors/warnings

**Return Type**:
```typescript
interface ConfigValidation {
  valid: boolean;
  errors: string[];      // Fatal errors (invalid JSON, unknown fields)
  warnings: string[];    // Non-fatal warnings (deprecated options)
  normalized: AuditConfig; // Normalized config with defaults applied
}
```

**Example**:
```typescript
const config = {
  severity_threshold: "Extreme", // Invalid value
  max_file_size_kb: -1,          // Invalid value
  strip_comments: true
};

const validation = await validate_config(JSON.stringify(config));

if (!validation.valid) {
  console.error("Configuration errors:");
  validation.errors.forEach(err => console.error(`  - ${err}`));
  // Output:
  // - Invalid severity_threshold: "Extreme" (must be Critical, High, Medium, Low, or Info)
  // - Invalid max_file_size_kb: -1 (must be positive)
}

if (validation.warnings.length > 0) {
  console.warn("Configuration warnings:");
  validation.warnings.forEach(warn => console.warn(`  - ${warn}`));
}

// Use normalized config
const normalizedConfig = validation.normalized;
```

**Use Cases**:
- Pre-flight validation in UI
- Configuration file linting
- CI/CD pipeline checks
- Error message generation

---

### 2.5 `get_version()` - Version Information

**Purpose**: Get library version for debugging and compatibility checks

```rust
#[wasm_bindgen]
pub fn get_version() -> String
```

**TypeScript Signature**:
```typescript
function get_version(): string
```

**Returns**: Semantic version string (e.g., "1.2.3")

**Example**:
```typescript
const version = get_version();
console.log(`Using quantum-crypto-audit v${version}`);

// Check minimum version
const MIN_VERSION = "1.0.0";
if (compareVersions(version, MIN_VERSION) < 0) {
  throw new Error(`Requires v${MIN_VERSION} or higher`);
}
```

---

## 3. Type Definitions

### 3.1 `AuditReport` - Main Output Type

```typescript
interface AuditReport {
  findings: Finding[];
  risk_score: RiskScore;
  summary: AuditSummary;
  metadata: AuditMetadata;
}
```

### 3.2 `Finding` - Individual Security Issue

```typescript
interface Finding {
  id: string;              // Unique finding ID (e.g., "RSA-001-crypto.py:42")
  severity: Severity;
  pattern_type: string;    // Pattern type (e.g., "RSA", "ECC")
  location: Location;
  description: string;     // Human-readable description
  recommendation: string;  // How to fix
  confidence: number;      // 0.0 - 1.0
}

type Severity = "Critical" | "High" | "Medium" | "Low" | "Info";

interface Location {
  file: string;            // File path
  line: number;            // Line number (1-indexed)
  column: number;          // Column number (1-indexed)
  snippet: string;         // Code snippet for context
}
```

### 3.3 `RiskScore` - Aggregated Risk Assessment

```typescript
interface RiskScore {
  total: number;           // Numeric score (0-10+)
  critical_count: number;
  high_count: number;
  medium_count: number;
  low_count: number;
  risk_level: RiskLevel;
}

type RiskLevel = "Catastrophic" | "High" | "Medium" | "Low";
```

### 3.4 `AuditSummary` - High-Level Statistics

```typescript
interface AuditSummary {
  total_files: number;
  total_lines: number;
  total_findings: number;
  quantum_vulnerable_count: number; // Findings with quantum_vulnerable=true
  languages_detected: string[];
  execution_time_ms: number;
}
```

### 3.5 `AuditMetadata` - Audit Context

```typescript
interface AuditMetadata {
  library_version: string;  // e.g., "1.0.0"
  timestamp: string;        // ISO 8601 timestamp
  config: AuditConfig;      // Config used for audit
}
```

### 3.6 `AuditConfig` - Configuration Options

```typescript
interface AuditConfig {
  // Minimum severity to report (filters lower severities)
  severity_threshold?: Severity; // Default: "Low"

  // Pattern filtering (empty = all patterns)
  include_patterns?: string[];   // Pattern IDs to include
  exclude_patterns?: string[];   // Pattern IDs to exclude

  // Parsing options
  strip_comments?: boolean;      // Default: false
  max_file_size_kb?: number;     // Default: 10240 (10MB)

  // Detection options
  enable_context_validation?: boolean; // Default: true (reduces false positives)
}
```

---

## 4. Error Handling

### 4.1 Error Types

All errors are returned as rejected Promises with structured error objects:

```typescript
interface AuditError {
  error: string;      // Error type
  message: string;    // Human-readable message
  details?: any;      // Additional context
}
```

**Error Types**:

| Error Type | Description | Example |
|------------|-------------|---------|
| `ParseError` | File parsing failed | Invalid UTF-8, unsupported language |
| `DetectionError` | Pattern matching failed | Regex timeout, internal error |
| `ConfigError` | Invalid configuration | Invalid JSON, unknown field |
| `InvalidInput` | Input validation failed | File too large, empty content |
| `InternalError` | Unexpected internal error | WASM panic, memory error |

### 4.2 Error Handling Patterns

**Pattern 1: Try-Catch with Type Guard**
```typescript
try {
  const report = await audit_file(content, path, config);
  // Success path
} catch (error: unknown) {
  if (isAuditError(error)) {
    console.error(`Audit failed (${error.error}): ${error.message}`);
  } else {
    console.error("Unexpected error:", error);
  }
}

function isAuditError(error: unknown): error is AuditError {
  return typeof error === 'object' && error !== null && 'error' in error;
}
```

**Pattern 2: Result-Like Wrapper**
```typescript
async function safeAudit(content: string, path: string): Promise<Result<AuditReport>> {
  try {
    const report = await audit_file(content, path, "{}");
    return { ok: true, value: report };
  } catch (error) {
    return { ok: false, error: error as AuditError };
  }
}

type Result<T> =
  | { ok: true; value: T }
  | { ok: false; error: AuditError };

// Usage
const result = await safeAudit(code, "test.py");
if (result.ok) {
  console.log(result.value.findings);
} else {
  console.error(result.error.message);
}
```

---

## 5. Usage Examples

### 5.1 Basic Usage (Browser)

```html
<!DOCTYPE html>
<html>
<head>
  <title>Crypto Audit Demo</title>
</head>
<body>
  <textarea id="code" rows="20" cols="80"></textarea>
  <button onclick="runAudit()">Audit Code</button>
  <pre id="results"></pre>

  <script type="module">
    import init, { audit_file } from './pkg/quantum_crypto_audit.js';

    await init();

    window.runAudit = async function() {
      const code = document.getElementById('code').value;
      const results = document.getElementById('results');

      try {
        const report = await audit_file(code, "user_code.py", "{}");

        results.textContent = `
Found ${report.findings.length} issues
Risk Level: ${report.risk_score.risk_level}

Findings:
${report.findings.map(f => `
  [${f.severity}] Line ${f.location.line}: ${f.description}
  ‚Üí ${f.recommendation}
`).join('\n')}
        `;
      } catch (error) {
        results.textContent = `Error: ${error.message}`;
      }
    };
  </script>
</body>
</html>
```

### 5.2 Node.js CLI Tool

```typescript
#!/usr/bin/env node

import { readFile } from 'fs/promises';
import { audit_file, get_version } from './pkg/quantum_crypto_audit.js';

async function main() {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    console.log(`quantum-audit v${get_version()}`);
    console.log("Usage: quantum-audit <file>");
    process.exit(1);
  }

  const filePath = args[0];
  const content = await readFile(filePath, 'utf-8');

  const config = JSON.stringify({
    severity_threshold: "Medium",
    strip_comments: true
  });

  try {
    const report = await audit_file(content, filePath, config);

    console.log(`\nüìä Audit Report for ${filePath}`);
    console.log(`Risk Level: ${report.risk_score.risk_level}`);
    console.log(`Total Findings: ${report.findings.length}`);
    console.log(`  Critical: ${report.risk_score.critical_count}`);
    console.log(`  High: ${report.risk_score.high_count}`);
    console.log(`  Medium: ${report.risk_score.medium_count}`);

    if (report.findings.length > 0) {
      console.log("\nüîç Findings:");
      report.findings.forEach(f => {
        console.log(`\n[${f.severity}] Line ${f.location.line}`);
        console.log(`  ${f.description}`);
        console.log(`  üí° ${f.recommendation}`);
      });
    }

    process.exit(report.risk_score.critical_count > 0 ? 1 : 0);
  } catch (error) {
    console.error("‚ùå Audit failed:", error.message);
    process.exit(2);
  }
}

main();
```

### 5.3 CI/CD Integration (GitHub Actions)

```typescript
// scripts/audit-pr.ts

import { Octokit } from '@octokit/rest';
import { audit_directory } from './pkg/quantum_crypto_audit.js';

async function auditPullRequest() {
  const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
  const { owner, repo, pull_number } = getPRContext();

  // Get changed files
  const { data: files } = await octokit.pulls.listFiles({
    owner,
    repo,
    pull_number,
  });

  // Filter to code files
  const codeFiles = files.filter(f =>
    /\.(py|js|ts|go|java|rs)$/.test(f.filename)
  );

  // Fetch file contents
  const fileContents = await Promise.all(
    codeFiles.map(async f => ({
      path: f.filename,
      content: await fetchFileContent(owner, repo, f.sha)
    }))
  );

  // Run audit
  const report = await audit_directory(
    JSON.stringify(fileContents),
    JSON.stringify({ severity_threshold: "High" })
  );

  // Post comment on PR
  if (report.findings.length > 0) {
    const comment = formatComment(report);
    await octokit.issues.createComment({
      owner,
      repo,
      issue_number: pull_number,
      body: comment
    });

    if (report.risk_score.critical_count > 0) {
      console.error("‚ùå Critical quantum vulnerabilities found!");
      process.exit(1);
    }
  } else {
    console.log("‚úÖ No quantum vulnerabilities detected");
  }
}

function formatComment(report: AuditReport): string {
  return `
## üîê Quantum Crypto Audit Results

**Risk Level**: ${report.risk_score.risk_level}
**Total Findings**: ${report.findings.length}

${report.findings.map(f => `
### [${f.severity}] ${f.pattern_type} in \`${f.location.file}\`

**Line ${f.location.line}**: ${f.description}

**Recommendation**: ${f.recommendation}

\`\`\`
${f.location.snippet}
\`\`\`
`).join('\n---\n')}

<sub>Generated by quantum-crypto-audit v${report.metadata.library_version}</sub>
  `;
}
```

### 5.4 VS Code Extension Integration

```typescript
// extension.ts

import * as vscode from 'vscode';
import { audit_file } from './pkg/quantum_crypto_audit.js';

export function activate(context: vscode.ExtensionContext) {
  const diagnosticCollection = vscode.languages.createDiagnosticCollection('quantum-crypto');

  // Audit on save
  context.subscriptions.push(
    vscode.workspace.onDidSaveTextDocument(async (document) => {
      if (!shouldAudit(document)) return;

      const content = document.getText();
      const path = document.fileName;

      try {
        const report = await audit_file(content, path, "{}");

        const diagnostics = report.findings.map(f => {
          const range = new vscode.Range(
            f.location.line - 1,
            f.location.column - 1,
            f.location.line - 1,
            f.location.column + 10
          );

          const severity = mapSeverity(f.severity);
          const diagnostic = new vscode.Diagnostic(
            range,
            `${f.description}\n\nüí° ${f.recommendation}`,
            severity
          );
          diagnostic.source = 'quantum-crypto-audit';
          diagnostic.code = f.pattern_type;

          return diagnostic;
        });

        diagnosticCollection.set(document.uri, diagnostics);
      } catch (error) {
        vscode.window.showErrorMessage(`Audit failed: ${error.message}`);
      }
    })
  );
}

function mapSeverity(severity: string): vscode.DiagnosticSeverity {
  switch (severity) {
    case 'Critical': return vscode.DiagnosticSeverity.Error;
    case 'High': return vscode.DiagnosticSeverity.Error;
    case 'Medium': return vscode.DiagnosticSeverity.Warning;
    case 'Low': return vscode.DiagnosticSeverity.Information;
    default: return vscode.DiagnosticSeverity.Hint;
  }
}
```

---

## 6. Performance Considerations

### 6.1 Async Best Practices

```typescript
// ‚úÖ Good: Audit multiple files in parallel
const reports = await Promise.all(
  files.map(f => audit_file(f.content, f.path, config))
);

// ‚ùå Bad: Sequential auditing
for (const file of files) {
  const report = await audit_file(file.content, file.path, config);
}
```

### 6.2 Batching Strategy

```typescript
// For large codebases, use audit_directory with batching
const BATCH_SIZE = 50;

async function auditLargeCodebase(files: File[]): Promise<AuditReport> {
  const batches = chunk(files, BATCH_SIZE);

  const reports = await Promise.all(
    batches.map(batch =>
      audit_directory(JSON.stringify(batch), config)
    )
  );

  return mergeReports(reports);
}
```

### 6.3 Memory Management

```typescript
// For very large files, consider splitting
const MAX_CHUNK_SIZE = 50000; // 50k lines

if (lines.length > MAX_CHUNK_SIZE) {
  const chunks = splitIntoChunks(content, MAX_CHUNK_SIZE);
  const reports = await Promise.all(
    chunks.map((chunk, i) =>
      audit_file(chunk, `${path}:chunk${i}`, config)
    )
  );
}
```

---

## 7. API Versioning Strategy

### 7.1 Semantic Versioning

- **Major (1.x.x ‚Üí 2.x.x)**: Breaking API changes
- **Minor (1.1.x ‚Üí 1.2.x)**: New features, backward compatible
- **Patch (1.1.1 ‚Üí 1.1.2)**: Bug fixes, no API changes

### 7.2 Compatibility Promise

```typescript
// Version compatibility check
const MIN_SUPPORTED = "1.0.0";
const MAX_SUPPORTED = "1.999.999";

function checkCompatibility() {
  const version = get_version();
  if (compareVersions(version, MIN_SUPPORTED) < 0) {
    throw new Error(`Requires v${MIN_SUPPORTED} or higher`);
  }
  if (compareVersions(version, MAX_SUPPORTED) > 0) {
    console.warn(`Untested with v${version}, proceed with caution`);
  }
}
```

### 7.3 Deprecation Policy

Deprecated features will:
1. Show warning in validation results
2. Remain functional for 1 major version
3. Be removed in next major version

Example:
```typescript
// v1.5.0: Deprecation warning
const validation = await validate_config(JSON.stringify({
  deprecated_option: true // Warning added to validation.warnings
}));

// v2.0.0: Removed
// Config with deprecated_option will fail validation
```

---

## 8. Testing API

### 8.1 Test Helpers (Not in WASM, for host)

```typescript
// test-helpers.ts (not compiled to WASM)

export function createMockConfig(overrides?: Partial<AuditConfig>): string {
  return JSON.stringify({
    severity_threshold: "Low",
    strip_comments: false,
    max_file_size_kb: 10240,
    enable_context_validation: true,
    ...overrides
  });
}

export function createTestFile(
  path: string,
  lines: string[]
): { path: string; content: string } {
  return {
    path,
    content: lines.join('\n')
  };
}

export function assertFinding(
  report: AuditReport,
  predicate: (f: Finding) => boolean
): void {
  const found = report.findings.some(predicate);
  if (!found) {
    throw new Error("Expected finding not found in report");
  }
}
```

### 8.2 Integration Test Examples

```typescript
import { describe, test, expect } from '@jest/globals';
import { audit_file, get_supported_patterns } from './pkg/quantum_crypto_audit.js';

describe('API Integration Tests', () => {
  test('audit_file detects RSA usage', async () => {
    const code = `
from cryptography.hazmat.primitives.asymmetric import rsa
key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
    `;

    const report = await audit_file(code, "test.py", "{}");

    expect(report.findings.length).toBeGreaterThan(0);
    expect(report.findings[0].pattern_type).toBe("RSA");
    expect(report.findings[0].severity).toBe("Critical");
  });

  test('get_supported_patterns returns valid data', () => {
    const patterns = get_supported_patterns();

    expect(Array.isArray(patterns)).toBe(true);
    expect(patterns.length).toBeGreaterThan(0);
    expect(patterns[0]).toHaveProperty('id');
    expect(patterns[0]).toHaveProperty('name');
    expect(patterns[0]).toHaveProperty('quantum_vulnerable');
  });

  test('validate_config catches invalid severity', async () => {
    const config = { severity_threshold: "Invalid" };

    await expect(
      validate_config(JSON.stringify(config))
    ).rejects.toThrow();
  });
});
```

---

**End of API Design Document**

This API design provides:
- ‚úÖ Simple, intuitive interface (5 core functions)
- ‚úÖ Type-safe TypeScript definitions
- ‚úÖ Comprehensive error handling
- ‚úÖ Real-world usage examples
- ‚úÖ Performance best practices
- ‚úÖ Clear versioning strategy
